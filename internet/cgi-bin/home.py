print('Content-type: text/html; charset=utf-8')
print()
html = r'''<!DOCTYPE html><html lang="ru"><head><title>Объект Socket модуля socket в Python.</title><meta charset="utf-8"><meta name="description" content="Атрибуты и методы, определяемые объектом Socket. Все методы объекта Socket, за исключением метода .makefile(), соответствуют системным вызовам Unix, применимым к сокетам. Объекты Socket ​​поддерживают протокол диспетчера контекста. Выход из диспетчера контекста эквивалентен вызову функции close()."><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#e9e9e9"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="yandex-verification" content="7fc92983a5ae9810"><link rel="stylesheet" href="https://docs-python.ru/static/css/min.css"><link rel="icon" type="https://docs-python.ru/image/svg" href="https://docs-python.ru/favicon.svg"><meta property="og:image" content="https://docs-python.ru/favicon.svg"><style>.important-xl {min-height: calc(100vh - 140px);overflow:auto;}blockquote {padding-left: 1rem;font-style: italic;border-left: #6c757d 3px solid;}footer div {background-color: #e9e9e9;}code {background-color: #eeeeee; color:rgb(17, 17, 17);font-size:87%;}pre{color:#212529;border:1px silver solid;padding:5px;font-size:85%;display:block;width:100%;background-color: #eeeeee;margin-bottom:1rem;}.crimson, h3>em>code,h4>em>code,h5>em>code{line-height:1.2;margin-top:15px;color:crimson;background-color:#e9e9e9;}.big{font-size:120%}.small{font-size:80%}.small-grey{font-size:75%; color: dimgrey;}.table-bordered td{font-size:90%;}.table-bordered .color td{background-color:#E0E0E0; font-size:110%;text-align:center;}.breadcrumb {padding:2px 7px;margin:10px 0px 10px 0px;font-size:85%;}.no-gutters>.col-lg-9{margin-top:15px;}.card-header,.card-body{padding:10px 5px 5px 5px;}.overflow-auto.card-body {max-height: 600px;}.card-body>ul{padding:5px 5px 5px 20px; font-size:85%;}ol,ul,.card-body>ul>li{margin-top:5px;}.hr{width:90%;border:rgb(166, 209, 166) 1px solid;}.illuminate,.illuminate code{background-color:rgb(255, 255, 115);transition: 1s ease;}div[id^='yandex_rtb_R-A']{margin-bottom:10px;}#back-to-top {position:fixed;bottom:25px;left:25px;display:none;z-index:1001;}#msg-email,#msg-error,#okay{cursor:pointer;}#scroll{transition: 1s linear;}.blinking {background-color: rgb(51, 161, 51);}@media(max-width:768px){#container-msg-error {text-align:left !important;}}@media (max-width: 540px) {body{font-size:1.05rem !important;}pre{font-size:90%;}}#scroll::-webkit-scrollbar-track {-webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);background-color: #f5f5f5;}#scroll::-webkit-scrollbar {width: 3px;background-color: #f5f5f5;}#scroll::-webkit-scrollbar-thumb {background-color: #6c757d;}</style><script>window.yaContextCb=window.yaContextCb||[]</script><script src="https://yandex.ru/ads/system/context.js" async></script></head><body><div class="container-xl"><header><nav class="navbar navbar-expand-lg navbar-light rounded border" style="background-color: #e9e9e9;"><a class="navbar-brand" href="/" title="Python3, наиболее полный справочник/самоучитель."><b>Python3</b></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav mr-auto"><li class="nav-item "><a class="nav-link" href="/tutorial/" title="Справочник по языку Python3 на русском языке">Справочник Python</a></li><li class="nav-item active"><a class="nav-link" href="/standart-library/" title="Документация по стандартной библиотеки языка Python3">Стандартная библиотека</a></li><li class="nav-item "><a class="nav-link" href="/packages/" title="Сторонние популярные пакеты и модули">Другие модули</a></li><li class="nav-item"><a class="nav-link text-primary" href="https://t.me/docs_python_ru" title="Telegram-канал сайта docs-python.ru">Telegram</a></li><li class="nav-item "><a class="nav-link text-danger" href="/search/" title="Поиск по сайту docs-python.ru">Поиск</a></li><li class="nav-item"><span class="nav-link" id="msg-email" title="Письмо команде сайта docs-python.ru">Контакты</span></li></ul></div></nav></header></div><div class="container-xl"><div id="container-share-error" class="row no-gutters"><div id="container-ya-share" class="col-sm-12 col-md-6"><div class="ya-share2" data-services="vkontakte,odnoklassniki,messenger,whatsapp,viber,telegram,pocket,moimir"></div></div><div id="container-msg-error" class="col-sm-12 col-md-6 text-right"><span id="msg-error" class="badge badge-warning">Сообщить об ошибке.</span></div></div></div><div class="important-xl"><h1 class="text-center mt-3">Объект Socket модуля socket в Python.</h1><div id="important-info"><div id="yandex_rtb_R-A-1582037-2"></div><script>window.yaContextCb.push(()=>{Ya.Context.AdvManager.render({blockId: 'R-A-1582037-2',renderTo: 'yandex_rtb_R-A-1582037-2',})})</script></div><nav aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="/standart-library/" title="Справочник по стандартной библиотеке Python3.">Стандартная библиотека Python3.</a></li><li class="breadcrumb-item"><a href="/standart-library/modul-socket-setevoj-interfejs-python/" title="Низкоуровневый сетевой интерфейс в Python">Модуль socket, сетевой интерфейс в Python.</a></li><li class="breadcrumb-item active" aria-current="page">Объект Socket модуля socket в Python.</li></ol></nav><div class="row no-gutters"><div class="col-lg-9 pr-lg-1"><h2 class='h3'>Атрибуты и методы, определяемые объектом Socket.</h2><p>Все методы <a href="/standart-library/modul-socket-setevoj-interfejs-python/obekt-socket-modulja-socket/" title="Объект Socket модуля socket в Python.">объекта <code>Socket</code></a>, за исключением метода <a href="#Socket.close"><code>Socket.makefile()</code></a>, соответствуют системным вызовам Unix, применимым к сокетам.</p><p><a href="/standart-library/modul-socket-setevoj-interfejs-python/obekt-socket-modulja-socket/" title="Объект Socket модуля socket в Python.">Объекты <code>Socket</code></a> ​​поддерживают <a href="/tutorial/osnovnye-vstroennye-tipy-python/kontekstnyj-menedzher-with/" title="Контекстный менеджер with в Python">протокол диспетчера контекста</a>. Выход из диспетчера контекста эквивалентен вызову функции <a href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-close-modulja-socket/" title="Функция close() модуля socket в Python."><code>socket.close()</code></a>.</p><h3><u>Содержание</u>:</h3><ul><li><code>Socket.accept()</code> <a href="#Socket.accept">принимает соединение</a>,</li><li><code>Socket.bind()</code> <a href="#Socket.bind">привязывает сокет к адресу</a>,</li><li><code>Socket.close()</code> <a href="#Socket.close">закрывает сокет</a>,</li><li><code>Socket.connect()</code> <a href="#Socket.connect">подключает к удаленному сокету</a>,</li><li><code>Socket.connect_ex()</code> <a href="#Socket.connect_ex">работает подобно методу <code>Socket.connect(address)</code></a>,</li><li><code>Socket.detach()</code> <a href="#Socket.detach">переводит сокет в закрытое состояние</a>,</li><li><code>Socket.dup()</code> <a href="#Socket.dup">дублирует объект сокета</a>,</li><li><code>Socket.fileno()</code> <a href="#Socket.fileno">возвращает файловый дескриптор сокета</a>,</li><li><code>Socket.get_inheritable()</code> <a href="#Socket.get_inheritable">получает наследуемый флаг дескриптора сокета</a>,</li><li><code>Socket.getpeername()</code> <a href="#Socket.getpeername">возвращает удаленный адрес</a>,</li><li><code>Socket.getsockname()</code> <a href="#Socket.getsockname">возвращает собственный адрес</a>,</li><li><code>Socket.getsockopt()</code> <a href="#Socket.getsockopt">возвращает значение заданной опции сокета</a>,</li><li><code>Socket.getblocking()</code> <a href="#Socket.getblocking">проверяет режим блокировки</a>,</li><li><code>Socket.gettimeout()</code> <a href="#Socket.gettimeout">возвращает значение тайм-аут</a>,</li><li><code>Socket.ioctl()</code> <a href="#Socket.ioctl">ограниченный интерфейс для <code>WSAIoctl</code></a>,</li><li><code>Socket.listen()</code> <a href="#Socket.listen">переводит сервер для приема подключений</a>,</li><li><code>Socket.makefile()</code> <a href="#Socket.makefile">возвращает объект файла, связанный с сокетом</a>,</li><li><code>Socket.recv()</code> <a href="#Socket.recv">получает данные из сокета</a>,</li><li><code>Socket.recvfrom()</code> <a href="#Socket.recvfrom">получает данные из сокета</a>,</li><li><code>Socket.recvmsg()</code> <a href="#Socket.recvmsg">получает обычные и вспомогательные данные из сокета</a>,</li><li><code>Socket.recvmsg_into()</code> <a href="#Socket.recvmsg_into">получает нормальные и вспомогательные данные из сокета</a>,</li><li><code>Socket.recvfrom_into()</code> <a href="#Socket.recvfrom_into">получает данные из сокета</a>,</li><li><code>Socket.recv_into()</code> <a href="#Socket.recv_into">получает от сокета до <code>nbytes</code> байтов</a>,</li><li><code>Socket.send()</code> <a href="#Socket.send">отправляет данные в сокет</a>,</li><li><code>Socket.sendall()</code> <a href="#Socket.sendall">отправляет данные в сокет</a>,</li><li><code>Socket.sendto()</code> <a href="#Socket.sendto">отправляет данные в сокет</a>,</li><li><code>Socket.sendmsg()</code> <a href="#Socket.sendmsg">отправляет обычные и вспомогательные данные в сокет</a>,</li><li><code>Socket.sendmsg_afalg()</code> <a href="#Socket.sendmsg_afalg">специализированная версия <code>Socket.sendmsg()</code></a>,</li><li><code>Socket.send_fds()</code> <a href="#Socket.send_fds">отправляет через сокет список файловых дескрипторов</a>,</li><li><code>Socket.recv_fds()</code> <a href="#Socket.recv_fds">получает до <code>maxfds</code> файловых дескрипторов</a>,</li><li><code>Socket.sendfile()</code> <a href="#Socket.sendfile">отправляет файл до достижения EOF</a>,</li><li><code>Socket.set_inheritable()</code> <a href="#Socket.set_inheritable">устанавливает наследуемый флаг файлового дескриптора</a>,</li><li><code>Socket.setblocking()</code> <a href="#Socket.setblocking">устанавливает блокирующий или неблокирующий режим сокета</a>,</li><li><code>Socket.settimeout()</code> <a href="#Socket.settimeout">устанавливает тайм-аут для сокета</a>,</li><li><code>Socket.setsockopt()</code> <a href="#Socket.setsockopt">устанавливает значение опции сокета</a>,</li><li><code>Socket.shutdown()</code> <a href="#Socket.shutdown">отключает одну или обе половины соединения</a>,</li><li><code>Socket.share()</code> <a href="#Socket.share">копирует сокет и подготавливает его для использования с процессом</a>,</li><li><code>Socket.family</code> <a href="#Socket.family">возвращает семейство сокетов</a>,</li><li><code>Socket.type</code> <a href="#Socket.type">возвращает тип сокета</a>,</li><li><code>Socket.proto</code> <a href="#Socket.proto">возвращает протокол сокета</a>,</li><li><a href="#timeout">Примечания о тайм-аутах сокетов</a>.</li></ul><hr><p><a id="Socket.accept"></a></p><h4><em><code>Socket.accept()</code></em>:</h4><p>Метод <code>Socket.accept()</code> принимает соединение. </p><p>Сокет должен быть привязан к адресу и прослушивать соединения. Возвращаемое значение - это пара <code>(conn, address)</code>, где</p><ul><li><code>conn</code> - это новый <a href="/standart-library/modul-socket-setevoj-interfejs-python/obekt-socket-modulja-socket/" title="Объект Socket модуля socket в Python.">объект сокета</a>, который можно использовать для отправки и получения данных в соединении, </li><li><code>address</code> - это адрес, привязанный к сокету на другом конце соединения.</li></ul><p>Вновь созданный сокет не наследуется.</p><p><a id="Socket.bind"></a></p><h4><em><code>Socket.bind(address)</code></em>:</h4><p>Метод <code>Socket.bind()</code> привязывает сокет к адресу <code>address</code>. Сокет еще не должен быть привязан. </p><p>Формат адреса зависит от <a href="/standart-library/modul-socket-setevoj-interfejs-python/semejstva-soketov-podderzhivaemyh-modulem-socket/" title="Семейства сокетов, поддерживаемых модулем socket в Python.">семейства адресов</a>.</p><p>Вызывает <a href="/standart-library/modul-sys-python/sobytie-audita-c/" title="События аудита CPython.">событие аудита</a> <code>socket.bind</code> с аргументами <code>self</code>, <code>address</code>.</p><p><a id="Socket.close"></a></p><h4><em><code>Socket.close()</code></em>:</h4><p>Метод <code>Socket.close()</code> закрывает сокет. </p><p>Базовый системный ресурс (например, файловый дескриптор) также закрывается, когда закрываются все файловые объекты из <a href="#Socket.makefile"><code>Socket.makefile()</code></a>. Как только это произойдет, все будущие операции с объектом сокета завершатся ошибкой.</p><p>После того, как данные из очереди будут сброшены, удаленный сокет не будет получать больше данных.</p><p>Сокеты автоматически закрываются, когда они собираются сборщиком мусора, но рекомендуется явно закрыть их <code>Socket.close()</code> или использовать для них <a href="/tutorial/osnovnye-vstroennye-tipy-python/kontekstnyj-menedzher-with/" title="Контекстный менеджер with в Python">оператор <code>with</code></a>.</p><p>Изменено в Python 3.6: Если возникает ошибка при выполнении базового вызова <code>Socket.close()</code>, то  возникает <a href="/tutorial/vstroennye-iskljuchenija-interpretator-python/oshibki-operatsionnoj-sistemy-oserror/" title="Исключения операционной системы: OSError в Python.">исключение <code>OSError</code></a>.</p><p><u>Обратите внимание</u>, что <a href="#Socket.close"><code>Socket.close()</code></a> освобождает ресурс, связанный с соединением, но не обязательно немедленно закрывает соединение. Если необходимо своевременно закрыть соединение, то перед закрытием сокета <code>Socket.close()</code> вызовите метод <a href="#Socket.shutdown"><code>Socket.shutdown()</code></a>.</p><p><a id="Socket.connect"></a></p><h4><em><code>Socket.connect(address)</code></em>:</h4><p>Метод <code>Socket.connect()</code> подключается к удаленному сокету по адресу <code>address</code>. Формат адреса <code>address</code> зависит от <a href="/standart-library/modul-socket-setevoj-interfejs-python/semejstva-soketov-podderzhivaemyh-modulem-socket/" title="Семейства сокетов, поддерживаемых модулем socket в Python.">семейства адресов</a>.</p><p>Если соединение прерывается сигналом, а обработчик сигнала не вызывает исключение и сокет блокируется или имеет тайм-аут, то метод ожидает завершения соединения или вызывает <a href="/standart-library/modul-socket-setevoj-interfejs-python/oshibki-iskljuchenija-opredeljaemye-modulem-socket/" title="Ошибки и исключения, определяемые модулем socket в Python.">исключение <code>Socket.timeout</code></a>.</p><p>Для неблокирующих сокетов, если соединение прерывается сигналом или исключением, созданным обработчиком сигнала, то метод вызывает <a href="/tutorial/vstroennye-iskljuchenija-interpretator-python/oshibki-operatsionnoj-sistemy-oserror/" title="Исключения операционной системы: OSError в Python.">исключение <code>InterruptedError</code></a>, .</p><p>Вызывает <a href="/standart-library/modul-sys-python/sobytie-audita-c/" title="События аудита CPython.">событие аудита</a> <code>socket.connect</code> с аргументами <code>self</code>, <code>address</code>.</p><p>Изменено в Python 3.5: теперь метод ожидает завершения соединения вместо вызова исключения <code>InterruptedError</code>, если соединение прерывается сигналом, а обработчик сигнала не вызывает исключения и сокет блокируется или имеет тайм-аут.</p><p><a id="Socket.connect_ex"></a></p><h4><em><code>Socket.connect_ex(address)</code></em>:</h4><p>Метод <code>Socket.connect_ex()</code> работает подобно методу <a href="#Socket.connect"><code>Socket.connect(address)</code></a>, но вместо вызова исключения (возвращаемых вызовом <code>connect()</code> языка C) возвращает индикатор ошибки (Исключение может возникнуть, если не найден хост - &quot;host not found&quot;). </p><p>Индикатор ошибки равен 0, если операция прошла успешно, в противном случае, индикатор ошибки равен значению переменной <code>errno</code>. Метод <code>Socket.connect_ex()</code> полезен для поддержки, например, асинхронных подключений.</p><p>Вызывает <a href="/standart-library/modul-sys-python/sobytie-audita-c/" title="События аудита CPython.">событие аудита</a> <code>socket.connect</code> с аргументами <code>self</code>, <code>address</code>.</p><p><a id="Socket.detach"></a></p><h4><em><code>Socket.detach()</code></em>:</h4><p>Метод <code>Socket.detach()</code> переводит объект сокета в закрытое состояние, не закрывая дескриптор файла. </p><p>Возвращает дескриптор файла, который может быть повторно использован для других целей.</p><p><a id="Socket.dup"></a></p><h4><em><code>Socket.dup()</code></em>:</h4><p>Метод <code>Socket.dup()</code> дублирует объект сокета <code>Socket</code>. Вновь созданный сокет не наследуется.</p><p><a id="Socket.fileno"></a></p><h4><em><code>Socket.fileno()</code></em>:</h4><p>Метод <code>Socket.fileno()</code> возвращает файловый дескриптор сокета (небольшое <a href="/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-int-tselye-chisla/" title="Целые числа int в Python.">целое число</a>) или -1 в случае ошибки. </p><p>Метод <code>Socket.fileno()</code> полезен с системным вызовом Unix <a href="/standart-library/modul-select-python/funktsija-select-modulja-select/" title="Функция select() модуля select в Python."><code>select.select()</code></a>.</p><p>В Windows возвращаемое этим методом малое целое число, нельзя использовать там, где можно использовать дескриптор файла, например <a href="/standart-library/modul-os-python/sozdanie-deskriptora-chtenie-zapis-zakrytie/" title="Создание дескриптора файла, чтение, запись и его закрытие."><code>os.fdopen()</code></a>. Unix не имеет этого ограничения.</p><p><a id="Socket.get_inheritable"></a></p><h4><em><code>Socket.get_inheritable()</code></em>:</h4><p>Метод <code>Socket.get_inheritable()</code> получает наследуемый флаг дескриптора файла или дескриптора сокета. </p><p>Метод возвращает <code>True</code>, если сокет может быть унаследован в дочерних процессах, <code>False</code>, если нет.</p><p><a id="Socket.getpeername"></a></p><h4><em><code>Socket.getpeername()</code></em>:</h4><p>Метод <code>Socket.getpeername()</code> возвращает удаленный адрес, к которому подключен сокет. </p><p>Метод полезен, например, для определения номера порта удаленного сокета IPv4/v6. Формат возвращаемого адреса зависит от <a href="/standart-library/modul-socket-setevoj-interfejs-python/semejstva-soketov-podderzhivaemyh-modulem-socket/" title="Семейства сокетов, поддерживаемых модулем socket в Python.">семейства адресов</a>.</p><p>В некоторых системах эта функция не поддерживается.</p><p><a id="Socket.getsockname"></a></p><h4><em><code>Socket.getsockname()</code></em>:</h4><p>Метод <code>Socket.getsockname()</code> возвращает собственный адрес и порт сокета. </p><p>Метод полезен, например, для определения номера порта сокета IPv4/v6. Формат возвращаемого адреса зависит от <a href="/standart-library/modul-socket-setevoj-interfejs-python/semejstva-soketov-podderzhivaemyh-modulem-socket/" title="Семейства сокетов, поддерживаемых модулем socket в Python.">семейства адресов</a>.</p><div class="mt-3"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">12345</span><span class="p">))</span>
<span class="c1"># распаковать кортеж</span>
<span class="n">host</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">getsockname</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">host</span>
<span class="c1"># &#39;127.0.0.1&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">port</span>
<span class="c1"># 12345</span>
</pre></div><p>Если компьютер имеет маршрут, подключенный к Интернету с <strong>белым IP-адресом</strong>, то код ниже вернет этот IP-адрес, Если компьютер подключен к интернету при помощи <strong>серого IP-адреса</strong>, то в результате выполнения кода получим адрес подсети провайдера:</p><div class="mt-3"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_DGRAM</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s2">&quot;8.8.8.8&quot;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
<span class="n">host</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">getsockname</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">host</span>
<span class="c1"># &#39;10.10.10.13&#39;</span>
</pre></div><p>Можно использовать эту функцию для определения адреса компьютера в подсети провайдера, для которой не требуется маршрутизируемый доступ в Интернет.</p><div class="mt-3"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>

<span class="k">def</span> <span class="nf">extract_ip</span><span class="p">():</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_DGRAM</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>       
        <span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;10.255.255.255&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">ip</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">getsockname</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">ip</span> <span class="o">=</span> <span class="s1">&#39;127.0.0.1&#39;</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">st</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ip</span>


<span class="o">&gt;&gt;&gt;</span> <span class="n">extract_ip</span><span class="p">()</span>
<span class="c1"># &#39;10.10.10.13&#39;</span>
</pre></div><p><a id="Socket.getsockopt"></a></p><h4><em><code>Socket.getsockopt(level, optname[, buflen])</code></em>:</h4><p>Метод <code>Socket.getsockopt()</code> возвращает значение заданной опции сокета (смотрите man-страницу Unix командой <code>$ man getsockopt</code>). </p><p>Необходимые символьные <a href="/standart-library/modul-socket-setevoj-interfejs-python/konstanty-opredeljaemye-modulem-socket/" title="Константы, определяемые модулем socket в Python.">константы <code>socket.SO_*</code></a> и т. д. определены в <a href="/standart-library/modul-socket-setevoj-interfejs-python/" title="Модуль socket, сетевой интерфейс в Python.">модуле <code>socket</code></a>. </p><ul><li>Если аргумент <code>buflen</code> отсутствует, то предполагается целочисленный параметр, и метод возвращает его целое значение. </li><li>Если аргумент <code>buflen</code> присутствует, то он указывает максимальную длину буфера, используемого для приема опции, и этот буфер возвращается как <a href="/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-bytes-bajtovye-stroki/" title="Байтовые строки bytes в Python.">байтовый объект</a>. </li></ul><p>Вызывающий объект должен декодировать содержимое возвращаемого буфера. Чтобы узнать, как декодировать структуры языка С, закодированные как байтовые строки смотрите встроенный <a href="/standart-library/modul-struct-struktury-python/" title="Модуль struct, структуры C в Python.">модуль <code>struct</code></a>.</p><p><a id="Socket.getblocking"></a></p><h4><em><code>Socket.getblocking()</code></em>:</h4><p>Метод <code>Socket.getblocking()</code> возвращает <code>True</code>, если сокет находится в режиме блокировки, <code>False</code>, если в неблокирующем режиме.</p><p>Вызов метода эквивалентен проверке <code>Socket.gettimeout() == 0</code>.</p><p>Новое в Python 3.7.</p><p><a id="Socket.gettimeout"></a></p><h4><em><code>Socket.gettimeout()</code></em>:</h4><p>Метод <code>Socket.gettimeout()</code> возвращает значение тайм-аут <a href="/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-float-veschestvennye-chisla/" title="Вещественные числа float в Python."><code>float</code></a> в секундах или <code>None</code>, если тайм-аут не установлен. </p><p>Метод отражает последний вызов <a href="#Socket.setblocking"><code>Socket.setblocking()</code></a> или <a href="#Socket.settimeout"><code>Socket.settimeout()</code></a>.</p><p><a id="Socket.ioctl"></a></p><h4><em><code>Socket.ioctl(control, option)</code></em>:</h4><p><strong>Только для операционной системы Windows</strong>.</p><p>Метод <code>Socket.ioctl()</code> - это ограниченный интерфейс для системного интерфейса <code>WSAIoctl</code>. Для получения дополнительной информации, обратитесь к документации <code>Win32</code>.</p><p>На других платформах могут использоваться общие функции |<code>fcntl.fcntl()</code>| и |<code>fcntl.ioctl()</code>|. Они принимают объект сокета в качестве своего первого аргумента.</p><p>В настоящее время поддерживаются только следующие управляющие коды: <code>socket.SIO_RCVALL</code>, <code>socket.SIO_KEEPALIVE_VALS</code> и <code>socket.SIO_LOOPBACK_FAST_PATH</code>.</p><p>Изменено в Python 3.6: добавлен <code>socket.SIO_LOOPBACK_FAST_PATH</code>.</p><p><a id="Socket.listen"></a></p><h4><em><code>Socket.listen([backlog])</code></em>:</h4><p>Метод <code>Socket.listen()</code> переводит сервер для приема подключений. </p><p>Если задан необязательный аргумент <code>backlog</code>, то он должен быть не менее 0 (если меньше, то это равно 0). </p><p>Аргумент <code>backlog</code> указывает количество подключений, которые система поставит в очередь, перед отказом от новых подключений. Если не указано, то выбирается разумное значение по умолчанию.</p><p><a id="Socket.makefile"></a></p><h4><em><code>Socket.makefile(mode=&#39;r&#39;, buffering=None, *, encoding=None, errors=None, newline=None)</code></em>:</h4><p>Метод <code>Socket.makefile()</code> возвращает объект файла, связанный с сокетом. Точный возвращаемый тип зависит от аргументов, переданных в метод <code>Socket.makefile()</code>. Эти аргументы интерпретируются так же, как и встроенной <a href="/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-open/" title="Функция open() в Python, открывает файл на чтение/запись.">функцией функции <code>open()</code></a>, за исключением того, что поддерживаются только значения <code>mode</code> <code>&#39;r&#39;</code> (по умолчанию), <code>&#39;w&#39;</code> и <code>&#39;b&#39;</code>.</p><p>Сокет должен находиться в режиме блокировки. У него может быть установлен тайм-аут, но при этом, внутренний буфер файлового объекта может оказаться в несогласованном состоянии, если произойдет этот тайм-аут.</p><p>Закрытие файлового объекта, <code>Socket.makefile()</code>, не приведет к закрытию исходного сокета, если все остальные файловые объекты не были закрыты и <code>Socket.close()</code> не был вызван для объекта сокета.</p><p><u>Примечание</u>. В Windows файловый объект, созданный методом <code>Socket.makefile()</code>, нельзя использовать там, где ожидается файловый объект с файловым дескриптором, например как потоковые аргументы функции <a href="/standart-library/modul-subprocess-python/klass-popen-modulja-subprocess/" title="Класс Popen() модуля subprocess в Python."><code>subprocess.Popen()</code></a>.</p><p><a id="Socket.recv"></a></p><h4><em><code>Socket.recv(bufsize[, flags])</code></em>:</h4><p>Метод <code>Socket.recv()</code> получает данные из сокета. Возвращаемое значение - <a href="/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-bytes-bajtovye-stroki/" title="Байтовые строки bytes в Python.">байтовый объект</a>, представляющий полученные данные. </p><ul><li>Максимальный объем данных, которые должны быть получены за один раз, указывается в <code>bufsize</code>. </li><li>Информацию о значении необязательного аргумента <code>flags</code> (по умолчанию он равен нулю) смотрите на справочной странице по <code>recv(2)</code> Unix, командой <code>$ man recv</code>.</li></ul><p><u>Примечание</u>. Для наилучшего соответствия с аппаратными и сетевыми реалиями значение <code>bufsize</code> должно быть относительно небольшим, например 4096.</p><p><a id="Socket.recvfrom"></a></p><h4><em><code>Socket.recvfrom(bufsize[, flags])</code></em>:</h4><p>Метод <code>Socket.recvfrom()</code> получает данные из сокета. Возвращаемое значение - это парный <a href="/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-tuple-kortezh/" title="Кортеж tuple в Python.">кортеж</a> <code>(bytes, address)</code>, где <code>bytes</code> - это <a href="/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-bytes-bajtovye-stroki/" title="Байтовые строки bytes в Python.">байтовый</a> объект, представляющий полученные данные, а <code>address</code> - это адрес сокета, отправляющего данные. Формат адреса <code>address</code> зависит от <a href="/standart-library/modul-socket-setevoj-interfejs-python/semejstva-soketov-podderzhivaemyh-modulem-socket/" title="Семейства сокетов, поддерживаемых модулем socket в Python.">семейства адресов</a>.</p><p>Информацию о значении необязательного аргумента <code>flags</code> (по умолчанию он равен нулю) смотрите на справочной странице по <code>recv(2)</code> Unix, командой <code>$ man recv</code>. </p><p>Изменено в Python 3.7: для адреса IPv6, первый элемент адреса больше не содержит части <code>%scope_id</code>. Чтобы получить полный IPv6-адрес, используйте функцию <a href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-getnameinfo-modulja-socket/" title="Функция getnameinfo() модуля socket в Python."><code>socket.getnameinfo()</code></a>.</p><p><a id="Socket.recvmsg"></a></p><h4><em><code>Socket.recvmsg(bufsize[, ancbufsize[, flags]])</code></em>:</h4><p>Метод <code>Socket.recvmsg()</code> получает обычные данные до <code>bufsize</code> байтов и вспомогательные данные из сокета.</p><p>Аргумент <code>ancbufsize</code> устанавливает размер в байтах внутреннего буфера, используемого для приема вспомогательных данных. По умолчанию он равен 0, это означает, что дополнительные данные не будут получены. Соответствующие размеры буфера для вспомогательных данных можно вычислить с помощью  <a href="/standart-library/modul-socket-setevoj-interfejs-python/funktsii-cmsg-len-cmsg-space-modulja-socket/" title="Функции CMSG_LEN и CMSG_SPACE модуля socket в Python."><code>socket.CMSG_SPACE()</code></a> или  <a href="/standart-library/modul-socket-setevoj-interfejs-python/funktsii-cmsg-len-cmsg-space-modulja-socket/" title="Функции CMSG_LEN и CMSG_SPACE модуля socket в Python."><code>socket.CMSG_LEN()</code></a>, а элементы, которые не помещаются в буфер, могут быть усечены или отброшены. </p><p>Информацию о значении необязательного аргумента <code>flags</code> (по умолчанию он равен нулю) смотрите на справочной странице по <code>recv(2)</code> Unix, командой <code>$ man recv</code>.</p><p>Возвращаемое значение метода <code>Socket.recvmsg()</code> - это 4-<a href="/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-tuple-kortezh/" title="Кортеж tuple в Python.">кортеж</a>: <code>(data, ancdata, msg_flags, address)</code>. </p><ul><li>Элемент данных <code>data</code> - это байтовый объект, содержащий полученные основные данные. </li><li>Элемент <code>ancdata</code> представляет собой список из нуля или более кортежей <code>(cmsg_level, cmsg_type, cmsg_data)</code>, представляющих полученные вспомогательные данные (управляющие сообщения):<ul><li><code>cmsg_level</code> и <code>cmsg_type</code> - это целые числа, определяющие уровень протокола и специфичный для протокола тип соответственно, </li><li><code>cmsg_data</code> - это байтовый объект, содержащий связанные данные. </li></ul></li><li>Элемент <code>msg_flags</code> - это побитовое ИЛИ различных флагов, указывающих условия в полученном сообщении. подробности смотрите в документации к вашей системы. </li><li>Если принимающий сокет не подключен, то <code>address</code> является адресом отправляющего сокета, если он доступен, в противном случае его значение не указано.</li></ul><p>В некоторых системах методы <a href="#Socket.sendmsg"><code>Socket.sendmsg()</code></a> и <a href="#Socket.recvmsg"><code>Socket.recvmsg()</code></a> могут использоваться для передачи файловых дескрипторов между процессами через сокет <code>socket.AF_UNIX</code>. Когда это средство используется (оно часто ограничивается сокетами <code>socket.SOCK_STREAM</code>), то метод <a href="#Socket.recvmsg"><code>Socket.recvmsg()</code></a> будет возвращать в своих вспомогательных данных элементы формы <code>(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)</code>, где <code>fds</code> - байтовый объект, представляющий новые файловые дескрипторы как двоичный массив собственного типа языка C <code>int</code>. Если метод <a href="#Socket.sendmsg"><code>Socket.sendmsg()</code></a> вызывает исключение после возврата из системного вызова, то он сначала попытается закрыть все файловые дескрипторы, полученные через этот механизм.</p><p>Некоторые системы не указывают усеченную длину элементов вспомогательных данных, которые были получены только частично. Если кажется, что элемент выходит за пределы конца буфера, то <a href="#Socket.recvmsg"><code>Socket.recvmsg()</code></a> выдаст <code>RuntimeWarning</code> и вернет его часть, которая находится внутри буфера, при условии, что элемент не был усечен до начала связанных с ним данных.</p><p>В системах, поддерживающих механизм <code>socket.SCM_RIGHTS</code>, функция <code>recv_fds()</code> (смотрите ниже) будет получать дескрипторы файлов <code>maxfds</code>, возвращая данные сообщения и список, содержащий дескрипторы при игнорировании неожиданных условий, таких как получение несвязанных управляющих сообщений. Смотрите также метод объекта сокета <a href="#Socket.sendmsg"><code>Socket.sendmsg()</code></a>.</p><div class="mt-3"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">array</span>

<span class="k">def</span> <span class="nf">recv_fds</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msglen</span><span class="p">,</span> <span class="n">maxfds</span><span class="p">):</span>
    <span class="n">fds</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>   <span class="c1"># Array of ints</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">ancdata</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recvmsg</span><span class="p">(</span><span class="n">msglen</span><span class="p">,</span> <span class="n">Socket</span><span class="o">.</span><span class="n">CMSG_LEN</span><span class="p">(</span><span class="n">maxfds</span> <span class="o">*</span> <span class="n">fds</span><span class="o">.</span><span class="n">itemsize</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">cmsg_level</span><span class="p">,</span> <span class="n">cmsg_type</span><span class="p">,</span> <span class="n">cmsg_data</span> <span class="ow">in</span> <span class="n">ancdata</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cmsg_level</span> <span class="o">==</span> <span class="n">Socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span> <span class="ow">and</span> <span class="n">cmsg_type</span> <span class="o">==</span> <span class="n">Socket</span><span class="o">.</span><span class="n">SCM_RIGHTS</span><span class="p">:</span>
            <span class="c1"># Append data, ignoring any truncated integers at the end.</span>
            <span class="n">fds</span><span class="o">.</span><span class="n">frombytes</span><span class="p">(</span><span class="n">cmsg_data</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">cmsg_data</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cmsg_data</span><span class="p">)</span> <span class="o">%</span> <span class="n">fds</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">msg</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">fds</span><span class="p">)</span>
</pre></div><p>Доступность: большинство платформ Unix, возможно, и другие.</p><p><a id="Socket.recvmsg_into"></a></p><h4><em><code>Socket.recvmsg_into(buffers[, ancbufsize[, flags]])</code></em>:</h4><p>Метод <code>Socket.recvmsg_into()</code> получает нормальные и вспомогательные данные из сокета, ведя себя как <a href="#Socket.recvmsg">метод <code>Socket.recvmsg()</code></a>, но разбрасывает нормальные данные в ряд буферов вместо того, чтобы возвращать новый байтовый объект. </p><p>Аргумент <code>buffers</code> должен быть <a href="/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-iterator-iterator/" title="Итератор Iterator, протокол итератора в Python.">итерацией</a> объектов, экспортирующих записываемые буферы, например объекты <a href="/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-bytearray-bajtovyj-massiv/" title="Байтовый массив bytearray в Python."><code>bytearray</code></a>). Они будут заполняться последовательными фрагментами нормальных данных до тех пор, пока все они не будут записаны или пока <code>buffers</code> больше не останется. Операционная система может установить ограничение (<code>os.sysconf()</code> со значением <code>SC_IOV_MAX</code>) на количество буферов, которые могут быть использованы. </p><p>Аргументы <code>ancbufsize</code> имеет то же значение, что и для метода <a href="#Socket.recvmsg"><code>Socket.recvmsg()</code></a>.</p><p>Информацию о значении необязательного аргумента <code>flags</code> (по умолчанию он равен нулю) смотрите на справочной странице по <code>recv(2)</code> Unix, командой <code>$ man recv</code>.</p><p>Возвращаемое значение <code>Socket.recvmsg_into()</code> представляет собой 4-<a href="/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-tuple-kortezh/" title="Кортеж tuple в Python.">кортеж</a>: <code>(nbytes, ancdata, msg_flags, address)</code>, где </p><ul><li><code>nbytes</code> - это общее количество байтов нормальных данных, записанных в буферы, </li><li><code>ancdata</code>, <code>msg_flags</code> и <code>address</code> такие же, как для <a href="#Socket.recvmsg"><code>Socket.recvmsg()</code></a>.</li></ul><p>Пример:</p><div class="mt-3"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">socket</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">Socket</span><span class="o">.</span><span class="n">socketpair</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b1</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;----&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b2</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;0123456789&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b3</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;--------------&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s1</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Mary had a little lamb&#39;</span><span class="p">)</span>
<span class="c1"># 22</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s2</span><span class="o">.</span><span class="n">recvmsg_into</span><span class="p">([</span><span class="n">b1</span><span class="p">,</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b2</span><span class="p">)[</span><span class="mi">2</span><span class="p">:</span><span class="mi">9</span><span class="p">],</span> <span class="n">b3</span><span class="p">])</span>
<span class="c1"># (22, [], 0, None)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">]</span>
<span class="c1"># [bytearray(b&#39;Mary&#39;), bytearray(b&#39;01 had a 9&#39;), bytearray(b&#39;little lamb---&#39;)]</span>
</pre></div><p>Доступность: большинство платформ Unix, возможно, и другие.</p><p><a id="Socket.recvfrom_into"></a></p><h4><em><code>Socket.recvfrom_into(buffer[, nbytes[, flags]])</code></em>:</h4><p>Метод <code>Socket.recvfrom_into()</code> получает данные из сокета, записывая их в буфер вместо создания новой строки байтов. </p><p>Возвращаемое значение - это парный <a href="/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-tuple-kortezh/" title="Кортеж tuple в Python.">кортеж</a> <code>(nbytes, address)</code>, где </p><ul><li><code>nbytes</code> - это количество полученных байтов, </li><li><code>address</code> - адрес сокета, отправляющего данные. Формат адреса <code>address</code> зависит от <a href="/standart-library/modul-socket-setevoj-interfejs-python/semejstva-soketov-podderzhivaemyh-modulem-socket/" title="Семейства сокетов, поддерживаемых модулем socket в Python.">семейства адресов</a>.</li></ul><p>Информацию о значении необязательного аргумента <code>flags</code> (по умолчанию он равен нулю) смотрите на справочной странице по <code>recv(2)</code> Unix, командой <code>$ man recv</code>. </p><p><a id="Socket.recv_into"></a></p><h4><em><code>Socket.recv_into(buffer[, nbytes[, flags]])</code></em>:</h4><p>Метод <code>Socket.recv_into()</code> получает от сокета до <code>nbytes</code> байтов, сохраняя данные в буфере <code>buffer</code>, а не создавая новую строку байтов. </p><p>Если <code>nbytes</code> не указан или равен 0, то получает до размера, доступного в данном буфере. Возвращает количество полученных байтов.</p><p>Информацию о значении необязательного аргумента <code>flags</code> (по умолчанию он равен нулю) смотрите на справочной странице по <code>recv(2)</code> Unix, командой <code>$ man recv</code>. </p><p><a id="Socket.send"></a></p><h4><em><code>Socket.send(bytes[, flags])</code></em>:</h4><p>Метод <code>Socket.send()</code> отправляет данные в сокет. Отправляющий сокет должен быть подключен к удаленному сокету. </p><p>Необязательный аргумент <code>flags</code> имеет то же значение, что и для метода <a href="#Socket.recv"><code>Socket.recv()</code></a> выше. </p><p>Возвращает количество отправленных байтов. Приложения несут ответственность за проверку того, что все данные были отправлены. Если была передана только часть данных, то приложению необходимо попытаться доставить оставшиеся данные. </p><p>Для получения дополнительной информации по этой теме обратитесь к разделу &quot;<a href="/standart-library/modul-socket-setevoj-interfejs-python/rekomendatsii-programmirovaniju-soketov/" title="Советы по программированию сокетов в Python.">Рекомендации по программированию сокетов</a>&quot;.</p><p><a id="Socket.sendall"></a></p><h4><em><code>Socket.sendall(bytes[, flags])</code></em>:</h4><p>Метод <code>Socket.sendall()</code> отправляет данные в сокет. Отправляющий сокет должен быть подключен к удаленному сокету. </p><p>Необязательный аргумент <code>flags</code> имеет то же значение, что и для метода <a href="#Socket.recv"><code>Socket.recv()</code></a> выше. </p><p>В отличие от метода <a href="#Socket.send"><code>Socket.send()</code></a>, этот метод продолжает отправлять байтовые данные до тех пор, пока не будут отправлены все данные или не возникнет ошибка. В случае успеха ничего не возвращается. При ошибке возникает исключение и невозможно определить, сколько данных было успешно отправлено.</p><p><a id="Socket.sendto"></a></p><h4><em><code>Socket.sendto(bytes, address)</code></em><br><em><code>Socket.sendto(bytes, flags, address)</code></em>:</h4><p>Метод <code>Socket.sendto()</code> отправляет данные в сокет. Отправляющий сокет не должен быть подключен к удаленному сокету, поскольку сокет назначения указан в аргументе <code>address</code>. Формат адреса <code>address</code> зависит от <a href="/standart-library/modul-socket-setevoj-interfejs-python/semejstva-soketov-podderzhivaemyh-modulem-socket/" title="Семейства сокетов, поддерживаемых модулем socket в Python.">семейства адресов</a>.</p><p>Необязательный аргумент <code>flags</code> имеет то же значение, что и для метода <a href="#Socket.recv"><code>Socket.recv()</code></a> выше. </p><p>Метод <code>Socket.sendto()</code> возвращает количество отправленных байтов. Вызывает <a href="/standart-library/modul-sys-python/sobytie-audita-c/" title="События аудита CPython.">событие аудита</a> <code>socket.sendto</code> с аргументами <code>self</code>, <code>address</code>.</p><p><a id="Socket.sendmsg"></a></p><h4><em><code>Socket.sendmsg(buffers[, ancdata[, flags[, address]]])</code></em>:</h4><p>Метод <code>Socket.sendmsg()</code> отправляет обычные и вспомогательные данные в сокет, собирая обычные данные из ряда буферов и объединяя их в одно сообщение.</p><p>Аргумент <code>buffers</code> определяет обычные данные как <a href="/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-iterator-iterator/" title="Итератор Iterator, протокол итератора в Python.">итерацию</a> байтоподобных объектов (например, объектов <a href="/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-bytes-bajtovye-stroki/" title="Байтовые строки bytes в Python."><code>bytes</code></a>); Операционная система может установить ограничение (<code>os.sysconf()</code> со значением <code>SC_IOV_MAX</code>) на количество <code>buffers</code>, которые могут использоваться. </p><p>Аргумент <code>ancdata</code> указывает вспомогательные данные (управляющие сообщения) как <a href="/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-iterator-iterator/" title="Итератор Iterator, протокол итератора в Python.">итерацию</a> из нуля или более кортежей <code>(cmsg_level, cmsg_type, cmsg_data)</code>, где </p><ul><li><code>cmsg_level</code> и <code>cmsg_type</code> - целые числа, определяющие уровень протокола и тип, специфичный для протокола соответственно, </li><li><code>cmsg_data</code> - это байтоподобный объект, содержащий связанные данные. </li></ul><p><u>Обратите внимание</u>, что некоторые системы (в частности, системы без <a href="/standart-library/modul-socket-setevoj-interfejs-python/funktsii-cmsg-len-cmsg-space-modulja-socket/" title="Функции CMSG_LEN и CMSG_SPACE модуля socket в Python."><code>socket.CMSG_SPACE()</code></a>) могут поддерживать отправку только одного управляющего сообщения за вызов. </p><p>Необязательный аргумент <code>flags</code> имеет то же значение, что и для метода <a href="#Socket.recv"><code>Socket.recv()</code></a> выше. </p><p>Если аргумент <code>address</code> не равен <code>None</code>, то он устанавливает адрес назначения для сообщения. </p><p>Метод <code>Socket.sendmsg()</code> возвращает количество отправленных байтов обычных данных.</p><p>В примере ниже функция <code>send_fds()</code> отправляет список файловых дескрипторов <code>fds</code> через сокет <code>socket.AF_UNIX</code> в системах, поддерживающих механизм <code>socket.SCM_RIGHTS</code>. Смотрите также метод <a href="#Socket.recvmsg"><code>Socket.recvmsg()</code></a>.</p><div class="mt-3"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">array</span>

<span class="k">def</span> <span class="nf">send_fds</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">fds</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sock</span><span class="o">.</span><span class="n">sendmsg</span><span class="p">([</span><span class="n">msg</span><span class="p">],</span> <span class="p">[(</span><span class="n">Socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">Socket</span><span class="o">.</span><span class="n">SCM_RIGHTS</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">fds</span><span class="p">))])</span>
</pre></div><p>Доступность: большинство платформ Unix, возможно, другие.</p><p>Вызывает <a href="/standart-library/modul-sys-python/sobytie-audita-c/" title="События аудита CPython.">событие аудита</a> <code>socket.sendmsg</code> с аргументами <code>self</code>, <code>address</code>.</p><p><a id="Socket.sendmsg_afalg"></a></p><h4><em><code>Socket.sendmsg_afalg([msg, ]*, op[, iv[, assoclen[, flags]]])</code></em>:</h4><p>Метод <code>Socket.sendmsg_afalg()</code> это специализированная версия <a href="#Socket.sendmsg"><code>Socket.sendmsg()</code></a> для сокета <code>socket.AF_ALG</code>. </p><p>Устанавливает режим, IV, AEAD, связанную длину данных и флаги для сокета <code>socket.AF_ALG</code>.</p><p>Доступность: Linux &gt;= 2.6.38.</p><p>Новое в Python 3.6.</p><p><a id="Socket.send_fds"></a></p><h4><em><code>Socket.send_fds(sock, buffers, fds[, flags[, address]])</code></em>:</h4><p>Метод <code>Socket.send_fds()</code> отправляет список файловых дескрипторов <code>fds</code> через сокет <code>socket.AF_UNIX</code>. </p><p>Параметр <code>fds</code> представляет собой последовательность файловых дескрипторов. </p><p>Значение и поведение остальных аргументов метода смотрите в <a href="#Socket.sendmsg"><code>Socket.sendmsg()</code></a>.</p><p>Доступность: Unix поддерживает механизм <a href="#Socket.sendmsg"><code>Socket.sendmsg()</code></a> и <code>SCM_RIGHTS</code>.</p><p>Новое в Python 3.9.</p><p><a id="Socket.recv_fds"></a></p><h4><em><code>Socket.recv_fds(sock, bufsize, maxfds[, flags])</code></em>:</h4><p>Метод <code>Socket.recv_fds()</code> получает до <code>maxfds</code> файловых дескрипторов. Возвращает <code>(msg, list(fds), flags, addr)</code>. </p><p>Значение и поведение аргументов метода смотрите в <a href="#Socket.recvmsg"><code>Socket.recvmsg()</code></a>.</p><p>Доступность: Unix поддерживает механизм <a href="#Socket.recvmsg"><code>Socket.recvmsg()</code></a> и <code>SCM_RIGHTS</code>.</p><p>Новое в Python 3.9.</p><p><u>Обратите внимание</u> на любые усеченные целые числа в конце списка файловых дескрипторов.</p><p><a id="Socket.sendfile"></a></p><h4><em><code>Socket.sendfile(file, offset=0, count=None)</code></em>:</h4><p>Метод <code>Socket.sendfile()</code> отправляет файл до тех пор, пока не будет достигнут <code>EOF</code> с помощью высокопроизводительной системной функции <code>os.sendfile</code> и возвращает общее количество отправленных байтов. </p><p>Аргумент <code>file</code> должен быть обычным <a href="/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-file-object-fajly-potoki/" title="Файловый объект file object в Python.">файловым объектом</a>, открытым в двоичном режиме <code>mode=&#39;rb&#39;</code>. </p><p>Если системная функция <code>os.sendfile</code> недоступна (например, Windows) или файл не является обычным файлом, вместо него будет использоваться метод <a href="#Socket.send"><code>Socket.send()</code></a>.</p><p>Аргумент <code>offset</code> указывает, откуда начать чтение файла. </p><p>Аргумент <code>count</code>, если указан, то это общее количество байтов для передачи в отличие от отправки файла до достижения EOF. Положение файла обновляется при возврате или также в случае ошибки, в этом случае <a href="/standart-library/modul-io-python/klass-io-iobase-modulja-io/" title="Класс io.IOBase() модуля io в Python."><code>file.tell()</code></a> можно использовать для определения количества отправленных байтов. </p><p>Сокет должен быть типа <code>socket.SOCK_STREAM</code>. Неблокирующие сокеты не поддерживаются.</p><p><a id="Socket.set_inheritable"></a></p><h4><em><code>Socket.set_inheritable(inheritable)</code></em>:</h4><p>Метод <code>Socket.set_inheritable()</code> устанавливает наследуемый флаг <code>inheritable</code> файлового дескриптора сокета или дескриптора сокета.</p><p><a id="Socket.setblocking"></a></p><h4><em><code>Socket.setblocking(flag)</code></em>:</h4><p>Метод <code>Socket.setblocking()</code> устанавливает блокирующий или неблокирующий режим сокета: если флаг <code>False</code>, то сокет установлен в неблокирующий режим, в противном случае - в режим блокировки.</p><p>Этот метод является сокращением для некоторых вызовов <a href="#Socket.settimeout"><code>Socket.settimeout()</code></a>:</p><ul><li><code>Socket.setblocking(True)</code> эквивалентен <code>Socket.settimeout(None)</code>;</li><li><code>Socket.setblocking(False)</code> эквивалентен <code>Socket.settimeout(0.0)</code>.</li></ul><p>Изменено в Python 3.7: метод больше не применяет флаг <code>socket.SOCK_NONBLOCK</code> к <a href="#Socket.type"><code>Socket.type</code></a>.</p><p><a id="Socket.settimeout"></a></p><h4><em><code>Socket.settimeout(value)</code></em>:</h4><p>Метод <code>Socket.settimeout()</code> устанавливает тайм-аут для блокировки операций сокета. </p><p>Аргумент <code>value</code> может быть неотрицательным числом <a href="/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-float-veschestvennye-chisla/" title="Вещественные числа float в Python."><code>float</code></a>, выражающим секунды, или <code>None</code>. </p><ul><li>Если аргументу <code>value</code> задано ненулевое значение, то последующие операции сокета вызовут <a href="/standart-library/modul-socket-setevoj-interfejs-python/oshibki-iskljuchenija-opredeljaemye-modulem-socket/" title="Ошибки и исключения, определяемые модулем socket в Python.">исключение <code>socket.timeout</code></a>, если значение периода тайм-аута истекло до завершения операции.</li><li>Если <code>value=0</code>, то сокет переводится в неблокирующий режим. </li><li>Если <code>value=None</code>, то сокет переводится в режим блокировки.</li></ul><p>Для получения дополнительной информации смотрите &quot;<a href="#timeout">Примечания о тайм-аутах сокетов</a>&quot;.</p><p>Изменено в Python 3.7: метод больше не переключает флаг <code>socket.SOCK_NONBLOCK</code> на <a href="#Socket.type"><code>Socket.type</code></a>.</p><p><a id="Socket.setsockopt"></a></p><h4><em><code>Socket.setsockopt(level, optname, value: int)</code></em><br><em><code>Socket.setsockopt(level, optname, value: buffer)</code></em><br><em><code>Socket.setsockopt(level, optname, None, optlen: int)</code></em>:</h4><p>Метод <code>Socket.setsockopt()</code> устанавливает значение <code>value</code> данной опции <code>optname</code> сокета (см. Страницу руководства Unix setsockopt (2)). </p><p>Необходимые символьные <a href="/standart-library/modul-socket-setevoj-interfejs-python/konstanty-opredeljaemye-modulem-socket/" title="Константы, определяемые модулем socket в Python.">константы <code>socket.SO_*</code> и т. д.</a> определены в <a href="/standart-library/modul-socket-setevoj-interfejs-python/" title="Модуль socket, сетевой интерфейс в Python.">модуле <code>socket</code></a>. Значение <code>value</code> может быть целым числом, <code>None</code> или байтовым объектом, представляющим буфер. В последнем случае вызывающая сторона должна убедиться, что строка байтов содержит правильные биты (как кодировать структуры языка С в байтовые строки, смотрите встроенный <a href="/standart-library/modul-struct-struktury-python/" title="Модуль struct, структуры C в Python.">модуль <code>struct</code></a>). Если установлено значение <code>None</code>, то требуется аргумент <code>optlen</code>. Это эквивалентно вызову функции C <code>setsockopt()</code> с <code>optval=NULL и</code>optlen=optlen`.</p><p>Изменено Python 3.6: добавлена ​​форма <code>Socket.setsockopt(level, optname, None, optlen: int)</code>.</p><p><a id="Socket.shutdown"></a></p><h4><em><code>Socket.shutdown(how)</code></em>:</h4><p>Метод <code>Socket.shutdown()</code> отключает одну или обе половины соединения. </p><ul><li>Если <code>how=socket.SHUT_RD</code>, то дальнейшее получение запрещено. </li><li>Если <code>how=socket.SHUT_WR</code>, то дальнейшая отправка запрещена. </li><li>Если <code>how=socket.SHUT_RDWR</code>, то дальнейшая отправка и получение запрещены.</li></ul><p><a id="Socket.share"></a></p><h4><em><code>Socket.share(process_id)</code></em>:</h4><p>Метод <code>Socket.share()</code> копирует сокет и подготавливает его для совместного использования с целевым процессом. </p><p>Целевой процесс должен быть предоставлен с идентификатором процесса <code>process_id</code>. Результирующий объект <code>bytes</code> затем может быть передан целевому процессу с использованием некоторой формы межпроцессного взаимодействия и сокет может быть воссоздан там с помощью функции <a href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-fromshare-modulja-socket/" title="Функция fromshare() модуля socket в Python."><code>socket.fromshare()</code></a>. </p><p>После вызова этого метода можно безопасно закрыть сокет, поскольку операционная система уже продублировала его для целевого процесса.</p><p><u>Обратите внимание</u>, что нет методов <code>read()</code> или <code>write()</code>, вместо них используйте методы <a href="#Socket.recv"><code>Socket.recv()</code></a> и <a href="#Socket.send"><code>Socket.send()</code></a> без аргумента flags.</p><p>Доступность: Windows.</p><p><a id="Socket.family"></a></p><h4><em><code>Socket.family</code></em>:</h4><p>Атрибут <code>Socket.family</code> возвращает <a href="/standart-library/modul-socket-setevoj-interfejs-python/semejstva-soketov-podderzhivaemyh-modulem-socket/" title="Семейства сокетов, поддерживаемых модулем socket в Python.">семейство сокетов</a> (только для чтения). </p><p><a id="Socket.type"></a></p><h4><em><code>Socket.type</code></em>:</h4><p>Атрибут <code>Socket.type</code> возвращает тип сокета (только для чтения). </p><p><a id="Socket.proto"></a></p><h4><em><code>Socket.proto</code></em>:</h4><p>Атрибут <code>Socket.proto</code> возвращает протокол на котором работает сокет (только для чтения).</p><hr><p><a id="timeout"></a></p><h2>Примечания о тайм-аутах сокетов.</h2><p>Объект сокета может находиться в одном из трех режимов: блокирующий, неблокирующий или тайм-аут. По умолчанию сокеты всегда создаются в режиме блокировки, но это можно изменить, вызвав функцию <a href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-getdefaulttimeout-modulja-socket/" title="Функции getdefaulttimeout() и setdefaulttimeout() модуля socket в Python."><code>socket.setdefaulttimeout()</code></a>.</p><ul><li>В <strong>режиме блокировки</strong>, операции блокируются до тех пор, пока не будут завершены или система не возвратит ошибку (например, истекло время ожидания соединения).</li><li>В <strong>неблокирующем режиме</strong> операции завершаются неудачно (с ошибкой, которая, к сожалению, зависит от системы), если они не могут быть выполнены немедленно: можно использовать функции из <a href="/standart-library/modul-select-python/" title="Модуль select в Python, отслеживание операций ввода/вывода.">модуля <code>select</code></a> для определения того, когда и доступен ли сокет для чтения или записи.</li><li>В режиме тайм-аута операции завершаются ошибкой, если они не могут быть завершены в течение тайм-аута, указанного для сокета (они вызывают <a href="/standart-library/modul-socket-setevoj-interfejs-python/oshibki-iskljuchenija-opredeljaemye-modulem-socket/" title="Ошибки и исключения, определяемые модулем socket в Python.">исключение <code>socket.timeout</code></a>) или если система возвращает ошибку.</li></ul><p><u>Примечание</u>. На уровне операционной системы сокеты в режиме тайм-аута внутренне устанавливаются в неблокирующий режим. Кроме того, режимы блокировки и тайм-аута используются совместно дескрипторами файлов и объектами сокетов, которые относятся к одной и той же конечной точке сети. Эта деталь реализации может иметь видимые последствия, если, например, вы решили использовать метод сокета <a href="#Socket.fileno"><code>Socket.fileno()</code></a>.</p><h3>Тайм-ауты и метод подключения.</h3><p>Операция соединения <a href="#Socket.connect"><code>Socket.connect()</code></a> также зависит от установки тайм-аута, и в целом рекомендуется вызвать <a href="#Socket.settimeout"><code>Socket.settimeout()</code></a> перед вызовом <a href="#Socket.connect"><code>Socket.connect()</code></a> или передать параметр <code>timeout</code> в функцию <a href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-create-connection-modulja-socket/" title="Функция create_connection() модуля socket в Python."><code>socket.create_connection()</code></a>. </p><p>Однако системный сетевой стек может также возвращать собственную ошибку тайм-аута соединения независимо от любого параметра тайм-аута сокета Python.</p><h3>Тайм-ауты и метод <code>Socket.accept()</code>.</h3><p>Если результат функции <a href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-getdefaulttimeout-modulja-socket/" title="Функции getdefaulttimeout() и setdefaulttimeout() модуля socket в Python."><code>socket.getdefaulttimeout()</code></a> не равен <code>None</code>, то сокеты, возвращаемые методом <a href="#Socket.accept"><code>Socket.accept()</code></a>, наследуют этот тайм-аут. В противном случае поведение зависит от настроек прослушивающего сокета:</p><ul><li>если прослушивающий сокет находится в <strong>режиме блокировки</strong> или в режиме тайм-аута, то сокет, возвращаемый функцией <a href="#Socket.accept"><code>Socket.accept()</code></a>, находится в режиме блокировки;</li><li>если прослушивающий сокет находится в <strong>неблокирующем режиме</strong>, то состояние сокета, возвращаемый методом <a href="#Socket.accept"><code>Socket.accept()</code></a>, полностью зависит от операционной системы. Если необходимо обеспечить кросс-платформенное поведение, то рекомендуется вручную переопределить этот параметр.</li></ul></div><div class="col-lg-3"><aside class="card shadow-sm border-secondary mb-2"><div class="card-header text-center bg-secondary text-white"><h4 class="h4">Содержание раздела:</h4></div><div id="scroll" class="overflow-auto card-body"><ul><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/brief-description/" title="Краткий обзор раздела: Модуль socket, сетевой интерфейс в Python.">КРАТКИЙ ОБЗОР МАТЕРИАЛА.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/rekomendatsii-programmirovaniju-soketov/" title="Советы по программированию сокетов в Python.">Советы по программированию сокетов.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/konstanty-opredeljaemye-modulem-socket/" title="Константы, определяемые модулем socket в Python.">Константы, определяемые модулем socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/semejstva-soketov-podderzhivaemyh-modulem-socket/" title="Семейства сокетов, поддерживаемых модулем socket в Python.">Семейства сокетов, поддерживаемых модулем socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-socket-modulja-socket-sozdaet-novyj-soket/" title="Создает подключение к новому сокету в Python.">Функция socket() модуля socket, создает новый сокет.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-create-connection-modulja-socket/" title="Создает TCP/IP клиента, который слушает Интернет адрес в Python.">Функция create_connection() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-create-server-modulja-socket/" title="Создает TCP/IP сервер, который слушает Интернет адрес в Python.">Функция create_server() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-socketpair-modulja-socket/" title="Создает клиентский и серверный подключенные сокеты в Python.">Функция socketpair() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-fromfd-modulja-socket/" title="Создает объект сокета из файлового дескриптора в Python.">Функция fromfd() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-fromshare-modulja-socket/" title="Создает подключение из данных, полученных методом socket.share() в Python.">Функция fromshare() модуля socket.</a></li><li><a class=text-muted href="/standart-library/modul-socket-setevoj-interfejs-python/obekt-socket-modulja-socket/" title="Атрибуты и методы, определяемые объектом Socket в Python.">Объект Socket модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-close-modulja-socket/" title="Закрывает дескриптор файла сокета в Python.">Функция close() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-getaddrinfo-modulja-socket/" title="По доменному имени и № порта получает сведения для подключения в Python.">Функция getaddrinfo() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-getfqdn-modulja-socket/" title="Получает доменное имя по IP-адресу в Python.">Функция getfqdn() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-gethostbyname-modulja-socket/" title="Получает IPv4-адрес по имени хоста/домена в Python.">Функция gethostbyname() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-gethostbyname-ex-modulja-socket/" title="Получает список IPv4-адресов, которые использует хост/домен в Python.">Функция gethostbyname_ex() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-gethostname-modulja-socket/" title="Получает имя хоста компьютера в Python.">Функция gethostname() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-gethostbyaddr-modulja-socket/" title="Получает имя хоста и IPv4/v6-адрес, закрепленный за интерфейсом в Python.">Функция gethostbyaddr() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-getnameinfo-modulja-socket/" title="Преобразует адрес сокета в кортеж (host, port) в Python.">Функция getnameinfo() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-getprotobyname-modulja-socket/" title="Получает константу для socket() по имени Интернет-протокола в Python.">Функция getprotobyname() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-getservbyname-modulja-socket/" title="Определяет номер порта, по имени протокола интернета в Python.">Функция getservbyname() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-getservbyport-modulja-socket/" title="Определяет имя протокола интернета по номеру порта в Python.">Функция getservbyport() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-has-dualstack-ipv6-modulja-socket/" title="Проверяет возможность создания TCP-сокета IPv4/IPv6 в Python.">Функция has_dualstack_ipv6() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-getdefaulttimeout-modulja-socket/" title="Установка/получение тайм-аута по умолчанию для создания новых сокетов в Python.">Функции getdefaulttimeout() и setdefaulttimeout() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsii-cmsg-len-cmsg-space-modulja-socket/" title="Длина и размер буфера для чтения данных из сокета в Python.">Функции CMSG_LEN и CMSG_SPACE модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-sethostname-modulja-socket/" title="Меняет имя хоста локальной машины на новое в Python.">Функция sethostname() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsija-if-nameindex-modulja-socket/" title="Получает информацию о сетевом интерфейсе компьютера в Python.">Функция if_nameindex() модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsii-if-nametoindex-if-indextoname-modulja-socket/" title="Получение номера сетевого интерфейса по его имени и обратная операция в Python.">Функции if_nametoindex() и if_indextoname модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/funktsii-razlichnyh-preobrazovanij-modulja-socket/" title="Функции преобразований порядка байтов и IPv4/v6 в двоичный формат и обратно в Python.">Функции различных преобразований модуля socket.</a></li><li><a  href="/standart-library/modul-socket-setevoj-interfejs-python/oshibki-iskljuchenija-opredeljaemye-modulem-socket/" title="Ошибки и исключения, определяемые модулем socket в Python.">Ошибки и исключения, определяемые модулем socket.</a></li></ul></div></aside><div id="right-row"><noindex><button id="donate-row" type="button" class="mt-2 mb-2 btn btn-outline-success btn-lg btn-block">ХОЧУ ПОМОЧЬ<br>ПРОЕКТУ</button></noindex><div id="yandex_rtb_R-A-1582037-1"></div><script>window.yaContextCb.push(()=>{Ya.Context.AdvManager.render({renderTo: 'yandex_rtb_R-A-1582037-1',blockId: 'R-A-1582037-1'})})</script></div></div></div><div id="dialogModal"></div></div><div class="container-xl"><footer><div id="back-to-top" class="btn btn-info">Вверх</div><div id="footer"><div class="card-body"><div class="card-text row pt-2 pb-2 ml-1 mr-1"><div class="col-sm-12 col-md-auto"><a href="/" title="Справочная документация по языку Python3.">DOCS-Python.ru</a>™, 2023 г.</div><div style="margin-left: auto;" class="col-sm-12 col-md-auto"><span class="small text-secondary">(<span class="text-danger">Внимание!</span> При копировании материала ссылка на источник обязательна)</span></div><div style="margin-left: auto;" class="col-sm-12 col-md-auto"><a href="https://t.me/docs_python_ru" title="Telegram-канал сайта docs-python.ru">@docs_python_ru</a></div></div></div></div></footer></div><script src="/static/js/min.js"></script><script>function sendError(msg, comment, h1) {$.ajax({type: "POST",url: "/send/error/",data: {'msg':msg, 'comment':comment, 'h1':h1},success: function(data) {var a = data.split('|');var resp = a.pop();if (resp.indexOf('ok') == 0) {Cookies.set('msgErr', '0');$('#errSend').remove();a.forEach(function(item) {b = item.split('#', 2);$('#'+b[0]).html(b[1]);});} else if (resp.indexOf('fatal') == 0) {$('#errSend').remove();a.forEach(function(item) {b = item.split('#', 2);$('#'+b[0]).html(b[1]);});} else {$('#errSend').text('Отправить').attr('disabled', false);$('#errTitle').css("color", "red").html(a.join('<br>'));}}});}function sendEmail(user, email, subject, msg) {$.ajax({type: "POST",url: "/send/email/",data: {'user':user, 'email':email, 'subject':subject, 'msg':msg},success: function(data) {var a = data.split('|');var resp = a.pop();if (resp.indexOf('ok') == 0) {$('#emailSend').remove();a.forEach(function(item) {b = item.split('#', 2);$('#'+b[0]).html(b[1]);});} else if (resp.indexOf('fatal') == 0) {$('#emailSend').remove();a.forEach(function(item) {b = item.split('#', 2);$('#'+b[0]).html(b[1]);});} else {$('#emailSend').text('Отправить').attr('disabled', false);$('#emailTitle').css("color", "brown").text('Исправте ошибки в письме.');a.forEach(function(item) {b = item.split('#');$('#'+b[0]).css("background-color", "rgb(252, 228, 228)");$('#_'+b[0]).text(b[1])});}}});}$(document).ready(function(){var h1 = $('h1').text();var w = $(document).width();$('pre').addClass('highlight');setTimeout(function(){var box = $('#right-row');if (w < 990){box.insertAfter('nav:eq(1)');} else {var top = box.offset().top;var width = box.width();$(document).on('scroll', function(){var windowpos = $(window).scrollTop();if(windowpos < top) {box.css('position', 'static');} else {box.attr('style', 'position:fixed !important;top:3px;width:'+width+'px;');}});}}, 1500);$("a[href^='#']").click(function(){$('.illuminate').removeClass('illuminate');var href = $(this).attr('href').replace('#', '');var el_a = $("a[id='" + href + "']");$("html, body").animate({scrollTop: el_a.offset().top + "px"}, 200);el_a.parent().next().addClass("illuminate");});$(document).scroll(function() {if ($(this).scrollTop() > 500) {$('#back-to-top').fadeIn();} else {$('#back-to-top').fadeOut();}});$('#back-to-top').click(function () {$('body,html').animate({scrollTop: 0}, 200);return false;});$('#donate-row').click(function() {$('.modal-backdrop').removeClass('show').hide();$("#dialogModal").html('');$.get("/static/form/modalDonate.html", function(data) {$("#dialogModal").html(data);$('#modalDonate').modal('show');});});$('#msg-error').click(function() {$('.modal-backdrop').removeClass('show').hide();$("#dialogModal").html('');$.get("/static/form/modalError.html", function(data) {$("#dialogModal").html(data);$('#modalError').modal('show');$('#errPageName').text(h1);});});$('#dialogModal').on('click', '#errSend', function() {$('#errSend').text('Идет отправка').attr('disabled', true);$('#emailTitle').css("color", "black").text('Ждите. Идет отправка...');var msg = $('#errText').val();var comment = $('#errCommentText').val();sendError(msg, comment, h1);});$('#msg-email').click(function() {$('.modal-backdrop').removeClass('show').hide();$("#dialogModal").html('');$("#dialogModal").load("/static/form/modalEmail.html", function(response,status) {if(status == "success") {$("#dialogModal").html(response);$('#modalEmail').modal('show');}});});$('#dialogModal').on('click', '#emailSend', function() {$('#emailSend').text('Идет отправка').attr('disabled', true);$('#emailTitle').css("color", "black").text('Ждите. Идет отправка...');var user = $('#user').val();var email = $('#email').val();var subject = $('#subject').val();var msg = $('#msg').val();sendEmail(user, email, subject, msg);});var right_menu = $("#scroll>ul>li:first").text();if ($(document).width() < 990 && right_menu) {var razdel = $(".breadcrumb-item:eq(1)").text().replace('.', ':');$('#navbarSupportedContent>ul>li:last').text(razdel);$("#scroll>ul").insertAfter('#navbarSupportedContent>ul>li:last');$('aside').remove();}});</script><script type="text/javascript" >(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(67309303, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/67309303" style="position:absolute; left:-9999px;" alt="" /></div></noscript><script src="//yastatic.net/share2/share.js"></script></body></html>'''
print(html)